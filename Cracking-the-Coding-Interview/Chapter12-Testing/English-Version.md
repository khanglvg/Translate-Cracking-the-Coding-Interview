# Testing
## Concepts and Algorithms: Solutions

> **Example 1:**
	Find the mistake(s) in the following code:
  ```
  unsigned int i;
  for (i = 100; i >= 0; --i)
    printf("%d\n", i);
  ```

#### **Solution**

There are two mistakes in this code.

_First,_ note that an `unsigned int` is, bay definition, always greater than or equal to zero. 
The `for` loop condition will therefore always be true, and it will loop infinitely.

=> The correct code to print all numbers from 100 to 1, is `i > 0`. If we truly wanted to print zero, we could add an additional `printf` statement after the `for` loop.

   ```
  unsigned int i;
  for (i = 100; i > 0; --i)
    printf("%d\n", i);
  ```
  _Second_ One additional correction is to use `%u` in place of `%d`, as we are printing `unsigned int`:
  
  ```
  unsigned int i;
  for (i = 100; i > 0; --i)
    printf("%u\n", i);
  ```
 :purple_heart: This code will now correctly print the list of all numbers from 100 to 1, in descending order. :purple_heart:
  
  ___
  
  > **Example 2:** 
    You are given the source to an application which crashes when it is run. After running it ten times in a debugger, you find it never crashes in the same place. The application is single threaded, and uses only the C standard library. What programming errors could be causing this crash? How would you test each one?
  
 #### **Solution**
  
The question largely depends on the type of application being diagnosed. However, we can give some general causes of random crashes. 
  1. _"Random Variable:"_ The application may use some random number or variable component that may not be fixed for every execution of the program. 
      - Examples include user input, a random number generated by the program, or the time of day.
  2. _Uninitialized Variable:_ The application could have an uninitialized variable which, in some languages, may cause it to take on an arbitrary value. The Values of this variable could result in the code taking a slightly different path each time.
  3. _Memory Leak:_  The program may have run out of memory. Other culprits are totally random for each run since it depends on the number of processes running at that particular time. This also includes heap overflow or corruption of data on the stack.
  4. _External Dependencies:_  The program may depend on another application, machine, or resource. If there are multiple dependencies, the program could crash at any point.
  
 To track down the issue, we should start with learning as much as possible about the application. :joy::joy::joy:
  - "Who is running it?"
  - "What are they doing with it?"
  - "What kind of application is it?"
  - ...
  
:point_right:  Additionally, although the application doesn't crash in exactly the same place, it's possible that it is linked to specific components or scenarios.
- For example, it could be that the application never crashes if it's simply launched and left untouched, and that crashes only appear at some point after loading a file. Or, it may be that all the crashes take place within the lower level components, such as file I/O.

:point_right:  It may be useful to approach this by elimination. Close down all other applications on the system. Track resource use very careful. If there are parts of the program we can disable, do so. Run it on a different machine and see if we experience the same issue. The more we can eliminate (or change), the easier we can track down the issue.

:point_right:  Additionally, we may be able to use tools to check for specific situations.
	       -  For example, to investigate issue #2, we can utilize runtime tools which check for _uninitialized variables_.
         
:point_right:  These problems are as much about your brainstorming ability as they are about your approach. Do you jump all over the place, shouting out random suggestions? Or do you approach it in a logical, structured manner? Hopefully, it's the latter.

___

> **Ví dụ 3:**
   We have the following method used in a chess game: boolean canMoveTo(int x, int y). This method is part of the Piece class and returns whether or not the piece can move to position (x, y). Explain how you would test this method. 
